<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML DOM (2)]]></title>
    <url>%2F2019%2F08%2F22%2FDOM2%2F</url>
    <content type="text"><![CDATA[节点属性nodeName, nodeValue, nodeType这三个属性的值取决于节点的类型 nodeName&emsp;节点名称 元素节点的 nodeName 是标签名称 (大写) 属性节点的 nodeName 是属性名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document console.log(document.nodeName); //#document console.log(element.nodeName); //DIV console.log(attr.nodeName); //id console.log(text.nodeName); //#text nodeValue&emsp;节点值 对于文本节点，nodeValue 属性包含文本。 对于属性节点，nodeValue 属性包含属性值。 文档节点和元素节点，nodeValue 属性的值始 nodeType&emsp;节点类型 常量名 常量值 节点类型 描述 Node.ELEMENT_NODE 1 Element 代表元素节点 Node.ATTRIBUTE_NODE 2 Attr 代表属性节点 Node.TEXT_NODE 3 Text 代表文本节点 Node.COMMENT_NODE 8 Comment 代表注释节点 Node.DOCUMENT_NODE 9 Document 代表整个文档 常用属性textContent / innerText / innerHTML&lt;div id="element"&gt; &lt;p&gt;Test text&lt;/p&gt; &lt;/div&gt; var element = document.getElementById('element') console.log(element.innerHTML) // &lt;p&gt;Test text&lt;/p&gt; console.log(element.innerText) //Test text console.log(element.textContent)// Test text innerHTML : 获取节点内的元素与文本 , 以 string 类型存储innerText : 获取节点内的文本 ( 不包括空白字符 )textContent : 获取节点内的文本 ( 包括空白字符 ) parentNode / parentElement&emsp;父节点 / 父元素取得某一节点的父节点 / 取得某一节点的父元素一般情况下 , 这两种属性的值是相等的 , 特例为根节点 document , document 属于节点 , 但不是元素节点 , 此时 parentNode 的值为#document , 但 parentElement 的值为 null previousSibling / previousElementChild&emsp;前一个兄弟节点 / 前一个兄弟元素previousSibling 不仅能够返回子元素(ElementNode) , 还可能取得文本节点(TextNode) , 谨慎使用IE8以下浏览器中 previousSibling 会取得前一个兄弟元素 , 且不支持previousElementChild nextSibling / nextElementChild&emsp;下一个兄弟节点 / 下一个兄弟元素使用方法 , 特性及兼容性与 previousSibling / previousElementChild 相似 childNodes / children&emsp;子节点集合 / 子元素集合同 firstChild / firstElementChild , childNodes 能够取得文本节点 , 但 children 只会取得元素节点在 firefox 与 chrome 等主流浏览器中 , 会将 空格 / 制表符 / 换行 等空白字符解析为空的文本节点 , 在使用 childNodes 时 , 需要注意这些空白字符 firstChild / firstElementChild&emsp;首个子节点 / 首个子元素取得某一节点的第一个子节点 / 取得某一节点的第一个子元素firstChild 不仅能够取得子元素(ElementNode) , 还能取得文本节点(TextNode) , 谨慎使用 可使用 firstElementChild 获取节点的第一个元素节点 发现有如下写法 , 原发布者认为可以使用这种方法避免firstChild取得文本节点 , 而得到元素节点 firstChild(element);//ReferenceError: firstChild is not defined Firfox 与 Chrome 测试时报错 , 方法不可行 兼容性 : IE8 以下浏览器中 firstChild 会取得第一个元素节点 , firstElementChild 不兼容 lastChild / lastElementChild&emsp;最后一个子节点 / 最后一个子元素使用方法与特性与 firstChild / firstElementChild 相似兼容性 : IE8 以下浏览器 lastChild 会取得最后一个元素节点 , 不支持lastElementChild]]></content>
      <tags>
        <tag>JavaScript JS DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML DOM (1)]]></title>
    <url>%2F2019%2F08%2F20%2FDOM%2F</url>
    <content type="text"><![CDATA[HTML DOM 简介什么是HTML DOM?DOM是W3C的标准 , 它定义了访问 HTML 和 XML 文档的标准 , HTML DOM 则是专门适用于 HTML / XHTML 的文档对象模型 , 定义了访问和操作 HTML 文档的标准方法 , 并将 HTML 文档呈现为带有元素 , 属性与文本的树状结构HTML DOM 独立于平台和编程语言 , 它可被任何编程语言 , 如 Java , JavaScript 和 VBScript 使用 HTML DOM 是 HTML 的标准对象模型 HTML 的标准API W3C 标准 DOM 的功能 查询某个元素 查询某个元素的祖先、兄弟以及后代元素 获取、修改元素的属性 获取、修改元素的内容 创建、插入和删除元素 简而言之 , DOM 为页面中的实时数据交互提供了可能性 , JavaScript 通过 DOM 可以访问并操作 HTML 文档中的内容 DOM 节点DOM 节点分类 整个文档是一个文档节点 每个 HTML 元素是一个元素节点 元素内的文本是一个文本节点 每个元素属性是一个属性节点 注释为注释节点 HTML DOM 节点树 通过 HTML DOM , JavaScript 可以访问树中的任意节点 , 所有节点均可被修改 , 也可以创建或删除节点 获取元素节点 方法 描述 getElementById() 返回带有指定 ID 的元素 getElementsByTagName() 返回带有指定标签名的元素的节点列表 getElementsByClassName() 返回带有指定类名的元素的节点列表 appendChild() 把新的子节点添加到指定节点 removeChild() 删除子节点 replaceChild() 替换子节点 insertBefore() 在指定的子节点前面插入新的子节点 createAttribute() 创建属性节点 createElement() 创建元素节点 createTextNode() 创建文本节点 getAttribute() 返回指定的属性值 setAttribute() 把指定属性设置或修改为指定的值 removeAttribute() 删除指定的属性 document.getElementById(id)说明 : 按照指定 id 取得元素对象 如果 id 重复 , 则返回第一个对象document.getElementById(id) 的返回值是一个对象 , 有 value 和 length 等属性 document.getElementsByTagName(tagName)说明 : 按照标签名取得元素节点列表 此方法的返回值 , 看似是一个数组 , 实则是一个伪数组 , 只支持length属性 , 它是一个动态的元素节点集合 , 会根据 DOM 树的变化自动更新 如果想对getElementsByTagName()返回值调用数组方法 , 可将其转化为数组方法如下 var divObjs=document.getElementsByTagName("div"); // 方法一 Array.prototype.slice.call(divObjs); // 方法二 此方法IE不支持 Array.from(divObjs); // 方法三 : 声明一个空数组，遍历伪数组中的元素添加到空数组中。 &nbsp; document.getElementsByClassName(className)说明 : 按照指定 class 取得元素对象列表其返回值形式同getElementsByTagName() 注意 , IE8以下及以下浏览器 , 不支持此方法 , 请勿使用 IE8 及以下浏览器 node.appendChild(node)说明 : 在节点的子节点列表末尾添加节点 , 或将一个节点的子节点移动到另一个节点下 添加子节点&lt;ul id="list1"&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;/ul&gt; &lt;ul id="list2"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; var newNode=document.createElement("li"); var textNode = document.createTextNode('C'); newNode.appendChild(textNode);//创建节点 &lt;li&gt;C&lt;/li&gt; document.getElementById('list1').appendChild(newNode); //添加新节点到id为list的元素内 移动子节点&lt;ul id="list1"&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li id="li"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;/ul&gt; var li=document.getElementById("li"); document.getElementById('list1').appendChild(li); //移动 id 为 "li" 的节点到 id 为 list 的元素内 node.removeChild(node)说明 : 从DOM中删除子节点返回值为被删除的子节点 , 该节点已从DOM树中删除 , 但仍然存在于内存中 node.removeChild(child); 在这种情况下 , 被删除的节点很快会被内存管理回收 , 如果需要保留此节点 , 可使用如下方式 var nodeDel = node.removeChild(child); node.replaceChild(newNode, oldNode)说明 : 将某个节点替换为另一个 , 原节点会被从 DOM 树中删除返回值为原节点 (oldchild) node.insertBefore(newNode, existingnode)说明 : 将一个节点插入到另一个节点前返回值为新插入的节点 (newNode) 与 appendChild() 的作用有一定相似 , 但原理不同insertBefore() 在节点前插入节点 , 相对于兄弟节点appendChild() 在末尾插入节点 , 相对于父级节点 document.createAttribute(attribute)说明 : 创建一个指定名称的属性节点参数为属性名 , 返回值为 Attr 对象属性 , 此方法仅能创建一条属性 , 并不会设置具体属性值 设置属性值方法如下&lt;p&gt;test&lt;/p&gt; var attr = document.createAttribute("style"); attr.nodeValue = "color: #f06"; var p=document.getElementsByTagName('p')[0]; p.setAttributeNode(attr); 效果如下&lt;p style="color: #f06"&gt;test&lt;/p&gt; 注setAttribute() 方法与 createAttribute() 方法作用类似 , 但可以直接添加属性及属性值 , 使用更简便 element.setAttribute(attributename,attributevalue) document.createElement(tagName)说明 : 创建一个元素节点 , 即一个HTML元素返回值为新创建的元素 , 与 appendChild() 或 insertBefore() 方法搭配使用 , 以在任意位置插入一个新建节点 var btn = document.createElement("input"); btn.type = "button"; btn.value = "新建按钮"; document.createTextNode(data)说明 : 创建一个文本节点返回值为此文本节点对象 , 文本节点中的内容均为文本 , 无论其格式如何例如 var text = document.createTextNode("&lt;div&gt;Hello&lt;/div&gt;"); 在浏览器中会显示 &lt;div&gt;Hello&lt;/div&gt; 本身 , 而不会显示一个内容为 “ Hello” 的 div node.getAttribute(data)说明 : 取得某一节点的某一属性值返回此属性的属性值 , 是一个字符串 var node = document.getElementById('node'); console.log(node.getAttribute('name')); node.setAttribute(data)说明 : 添加指定的属性 , 并为其赋指定的值返回指定属性的属性值 , 如果这个指定的属性已存在 , 则仅设置 / 更改值 var node = document.getElementById('node'); node.setAttribute('name', 'thisIsTheNode'); node.removeAttribute(data)说明 : 删除指定的属性返回被删除的属性 , 此方法不支持 IE 浏览器 var node = document.getElementById('node'); node.removeAttribute('name');]]></content>
      <tags>
        <tag>JavaScript JS DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[兔子问题]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%85%94%E5%AD%90%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[兔子问题(斐波那契数列)总结问 : 兔子在出生两个月后成熟 , 一对成熟兔子在出生后第三个月后每个月能生出一对小兔子 , 假设, 第一个月有一对刚出生的兔子 , 如果所有兔子都不死 , 那么一年以后可以繁殖多少对兔子 由题可知,在最初的两个月中 , 兔子的总数保持不变 , 从第三个月开始 , 开始出现新生的兔子 本月新生兔子的数量 = 出生达到第三个月的兔子数量 即 本月新生兔子的数量 = 两个月之前出生的兔子数量 + 三个月前的兔子总数 而 “ 两个月之前出生的兔子数量 + 三个月前的兔子总数 “ 所得到的值 , 等于两个月前的兔子总数 那么 , 我们可以得到以下结论 在兔子不死的前提下 , 本月新生的兔子数量 , 等于两个月前的兔子总数 又有当前兔子总数 = 上月兔子总数 + 本月新生的兔子数量 由此可知 , 本月兔子总数 , 等于上月兔子总数 + 两个月前的兔子总数 上月兔子总数 + 两个月前的兔子总数 = ( 两个月前兔子总数 + 三个月前兔子总数 ) + ( 三个月前兔子总数 + 四个月前兔子总数 ) 以此类推 到这里 , 最困难的逻辑整理部分已经完成 以下为我的解决方案 , 利用了递归调用 1234function rabbit(n)&#123; if(n&lt;=2)&#123;return 1;&#125; return rabbit(n-1)+rabbit(n-2);&#125;]]></content>
      <tags>
        <tag>JavaScript JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐式类型转换]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[隐式转换不同类型的变量比较要先转类型, 通常发生在运算符加减乘除, 等于, 还有大于, 小于等 规则 字符串加数字, 数字就会转成字符串 数字减字符串, 字符串转成数字, 反之亦然 如果字符串不是纯数字, 就会返回 NaN 乘, 除, 大于, 小于的转换也是一样 字符串和数字比较时，字符串转数字 数字为布尔比较时，布尔转数字 字符串和布尔比较时，两者转数字 undefined等于null 例如 123456789101112console.log(10+'20') //2010 Stringconsole.log(10-'20')//-10 numberconsole.log(10-'one') //NaNconsole.log(10-'101a') //NaNconsole.log(10*'20') //200 numberconsole.log('10'*'20') //200 numberconsole.log(20/'10') //2 numberconsole.log('20'/'10') //2 numberconsole.log('20'/'one') //NaN 12345678console.log('0'==0) //trueconsole.log(0==false) //trueconsole.log('0'==false) //trueconsole.log(null==false) //falseconsole.log(undefined==false) //falseconsole.log(undefined==null) //true]]></content>
      <tags>
        <tag>JavaScript JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[显式类型转换]]></title>
    <url>%2F2019%2F08%2F19%2F%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[显式转换parseInt() &amp; parseFloat()123456789101112parseInt("1234blue"); //returns 1234parseInt("0xA"); //returns 10parseInt(" 22.5"); //returns 22parseInt("22 5"); //returns 22parseInt("blue"); //returns NaNparseFloat("1234blue"); //returns 1234.0parseFloat("0xA"); //returns NaNparseFloat(" 22.5 "); //returns 22.5parseFloat("22.34.5"); //returns 22.34parseFloat("0908"); //returns 908parseFloat("blue"); //returns NaN parse 意为 “解析”parseInt() 将值转换成整数, parseFloat() 将值转换成浮点数 这两个函数只能对 String 类型使用,其他类型会返回 NaN1234parseInt("AF", 16); //returns 175parseInt("10", 2); //returns 2parseInt("10", 8); //returns 8parseInt("10", 10); //returns 10 parsrInt() 可以进行进制转换, 将16进制, 8进制, 2进制或其他进制的字符串转换为整数, 进制由方法的第二个参数指定 123parseInt("010"); //returns 8parseInt("010", 8); //returns 8parseInt("010", 10); //returns 10 如果十进制数包含前导0, 那么最好指明第二个参数为10, 这样才不会意外地得到八进制的值 window.Number()可以将任意类型的参数mix转换为数值类型如果是布尔值, true和false分别被转换为1和0 如果是数字值, 返回本身 如果是null, 返回0 如果是undefined, 返回NaN 如果是字符串, 遵循以下规则 如果字符串中只包含数字, 则将其转换为十进制 ( 忽略前导 0 ) 如果字符串中包含有效的浮点格式, 将其转换为浮点数值 ( 忽略前导 0 ) 如果是空字符串, 返回 0 如果字符串中无以上格式, 则将其转换为NaN 如果是对象, 则调用对象的valueOf()方法, 然后依据前面的规则转换返回的值。如果转换的结果是NaN, 则调用对象的toString()方法, 再次依照前面的规则转换返回的字符串值123456789Number(null) //0Number(undefined) //NaNNumber(true) //1Number(false) //0Number(" 123 456 ")//NaNNumber(" 123456 ")//123456Number(" 123.456 ")//123.456Number(" 123.45.6 ")//NaN toString()除undefined和null之外的所有类型的值都具有toString()方法, 其作用是返回对象的字符串表示 对象 操作 Array 将 Array 的元素转换为字符串。结果字符串由逗号分隔, 且连接起来。 Boolean 如果 Boolean 值是 true, 则返回 “true”。否则, 返回 “false”。 Date 返回日期的文字表示法。 Error 返回一个包含相关错误信息的字符串。 Function 返回如下格式的字符串, 其中 functionname 是被调用 toString 方法函数的名称 : function functionname( ) { [native code] } Number 返回数字的文字表示。 String 返回 String 对象的值。 默认 返回 “[object objectname]”, 其中 objectname 是对象类型的名称。 String()将任何类型的值转换为字符串 如果有toString()方法, 则调用该方法 ( 不传递radix参数 ) 并返回结果 如果是null, 返回”null” 如果是undefined, 返回”undefined” window.Boolean()将任何类型的值转换为布尔值以下值会被转换为false : false, ””(空字符串), 0, NaN, null, undefined, 其余任何值都会被转换为true 12345678window.Boolean(false); //falsewindow.Boolean(""); //falsewindow.Boolean(0); //falsewindow.Boolean(NaN); //falsewindow.Boolean(null); //falsewindow.Boolean(undefined); //false//其余所有值都会返回 true 参考文献 : https://www.cnblogs.com/Juphy/p/7085197.html]]></content>
      <tags>
        <tag>JavaScript JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var, let, const]]></title>
    <url>%2F2019%2F08%2F19%2F%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[var, let, const1. 块级作用域在ECMAScript 6 标准中,引入了块级作用域的概念 块级作用域由 {} 包括, if 和 for 语句中的{}同样属于块级作用域2. let 与 var let 作为es6的语法, 想要JS中引入, 必须使用严格模式 ‘use strict’ var定义的变量, 没有块的概念, 可以跨块访问, 不能跨函数访问 let定义的变量, 只能在块作用域里访问, 不能跨块访问, 也不能跨函数访问。 3. constconst在定义时必须初始化, 且初始化后不能修改, 不能跨块访问1234const num = 10;num = 11;console.log(num);//输出invalid assignment to const `num' 对常量’num’的赋值无效12345const obj = &#123;name: 'Andy', age: '20'&#125;obj.name = 'Ed'console.log(obj.name)//输出Ed//对象obj中的值已更改 在声明的常量中保存的仅是对象的指针, 修改对象的属性不会改变对象的指针, 所以是被允许的]]></content>
      <tags>
        <tag>JavaScript JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 变量类型]]></title>
    <url>%2F2019%2F08%2F19%2FJS%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一. 基本类型 数据类型 描述 undefined 未定义, 未初始化变量的默认值 Null 空, 空指针, 空的引用 Boolean 布尔值, 有且仅有两个值, true/false, 真与假, 1与0 String 字符串 Number 整数, 浮点数, Infinity, NaN Null与undefined Null表示”无”, 没有对象,即此处不应有值 undefined表示”缺省值”, 未定义, 即此处有一个对象,但还没有定义 在比较时,Null与undefine相等 数字类型分为整数型与浮点型,浮点型即小数 浮点数数值中必须包括小数点, 且小数点后至少要有一个非 0 数字, 否则会被解析为整数 在记录超大或超小的数据时,可以使用科学计数法 Infinity, 正无穷大 NaN, Not a Number, 非数字类型 二. 引用类型(复杂类型) 引用类型变量的值 1234var obj1 = &#123;name: 'Andy', age: '20'&#125;;var obj2 = obj1;obj2.name = 'Ed';console.log(obj1.name); 由此可见, 引用类型变量的值是一个指针, 指向堆内存中的实际对象 赋值 : var person1 = {name: ‘Mary’, age: ‘18’}; 访问 : person1.name 引用类型的比较 123var person1 = &#123;&#125;;var person2 = &#123;&#125;;console.log(person1 == person2); //输出为 false 引用类型是按引用访问的, 比较两个对象的堆内存的地址是否相同, person1 和 person2在堆内存中地址是不同的,所以这是两个完全不同的对象, 返回false]]></content>
      <tags>
        <tag>JavaScript JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单行文本超出部分隐藏为省略号]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E9%83%A8%E5%88%86%E9%9A%90%E8%97%8F%E4%B8%BA%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[想要得到预想中的效果，需要四条属性 盒子的宽度，即 width: ; 定宽 禁止换行 white-space: nowrap; overflow: hidden; 溢出部分隐藏 text-overflow: ellipsis; 显示省略号代替被修剪的文本]]></content>
      <tags>
        <tag>CSS HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素类型]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、HTML元素分类根据css显示分类 , HTML元素被分为三种类型:块状元素 , 内联元素 , 可变元素 1.块状元素 ( block element ) 块状元素在网页中就是以块的形式显示 , 所谓块状就是元素显示为矩形区域 , 常用的块状元素包块div,dl,dt,dd,ol,ul,(h1-h6),p,form,hr,table,tr,td等； 默认情况下 , 块状元素都会占据一行 , 通俗地说 , 两个相邻块状元素不会出现并列显示的现象；默认情况下 , 块状元素会按顺序自上而下排列。 块状元素都可以定义自己的宽度和高度。 块状元素一般都作为其他元素的容器 , 它可以容纳其它内联元素和其它块状元素。 我们可以把这种容器比喻为一个盒子。 2.内联元素 ( inline element ) ( 或是行内元素、行间元素、内嵌元素 ) 常见的内联元素如 : a,span,i,em,strong,b , img , input等 内联元素的表现形式是始终以行内逐个进行显示 内联元素没有自己的形状 , 不能定义它的宽和高,它显示的宽度、高度只能根据所包含内容的高度和宽度来确定 , 它的最小内容单元也会呈现矩形形状 内联元素也会遵循盒模型基本规则 , 如可以定义padding ,border ,margin, background等属性 , 但个别属性不能正确显示 二、 元素类型的转换盒模型可通过display属性来改变元素的类型 display属性与属性值 (常用) 值 描述 inline 默认，显示为内联元素，元素前后没有换行符 flex 定义伸缩容器 none 此元素不会被显示 block 显示为块级元素，前后带有换行符 inline-block 元素的内容以块状显示 , 行内的其他元素显示在同一行( 只有这一个元素类型支持vertical-align属性 ) table-cell 此元素会作为一个表格单元格显示 list-item 此元素会作为列表显示 run-in 此元素会根据上下文作为块级元素或内联元素显示 table 此元素会作为块级表格来显示，表格前后带有换行符 inline-table 此元素会作为内联表格来显示，表格前后没有换行符 另注： 当元素设置了float属性后 , 就相当于给该元素加了display:block;属性 大部分块元素display属性值默认为block , 其中列表的默认值为list-item。 大部分内联元素的display属性值默认为inline,其中img,input , 默认为inline-block。 三、置换元素内联元素一般是不能设置宽高的 , 但是也有特殊情况 , 比如img是内联元素 , 但可以设置宽高 , 这让不少人迷惑。于是我们就要引入HTML中置换元素的概念。 置换元素 : 浏览器根据元素的标签和属性 , 来决定元素的具体显示内容。 例如 :浏览器会根据img标签的src属性的值来读取图片信息并显示出来input标签的type属性来决定是显示输入框 , 还是单选按钮等 不可替换元素 : html 的大多数元素是不可替换元素 , 即其内容直接表现给用户端 附录1 : 关于属性的继承什么叫继承？ 父盒子的属性 , 如果子盒子能够读取得到 , 那么就是可以继承。 不可继承 文本可继承 列表元素可继承 display letter-spacing list-style margin word-spacing list-style-type border white-space list-style-position padding line-height list-style-image background color height font min-height font-family max-height font-size width font-style min-width font-variant max-width font-weight overflow text-decoration position text-transform left direction right text-indent top text-align bottom z-index float clear table-layout vertical-align page-break-after page-bread-before unicode-bidi — 附录2 : 元素类型表块元素(block element) 元素 描述 address 地址 blockquote 块引用 center 局中对齐块 dir 目录列表 div 常用块级容器 , 也是css layout的主要标签 dl 定义列表 fieldset form控制组 form 交互表单 h1 大标题 h2 副标题 h3 3级标题 h4 4级标题 h5 5级标题 h6 6级标题 hr 水平分隔线 isindex input prompt menu 菜单列表 noframes frames可选内容 , ( 不支持frame的浏览器显示此区块内容 ) noscript 可选脚本内容 ( 对于不支持script的浏览器显示此内容 ) ol 排序表单 p 段落 pre 格式化文本 table 表格 ul 非排序列表 内联元素(inline element) 元素 描述 a 超链接或锚点 acronym 首字 bdo 定义文字的方向 b 粗体(不推荐) big 大字体 br 换行 cite 引用 code 计算机代码(在引用源码的时候需要) dfn 定义字段 em 强调 font 字体设定(不推荐) i 斜体 img 图片 input 输入框 kbd 定义键盘文本 label 表格标签 q 短引用 s 中划线(不推荐) samp 定义范例计算机代码 select 项目选择 small 小字体文本 span 常用内联容器 , 定义文本内区块 strike 中划线 strong 粗体强调 sub 下标 sup 上标 textarea 多行文本输入框 tt 电传文本 u 下划线 var 定义变量 abbr 缩写]]></content>
      <tags>
        <tag>HTML CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局]]></title>
    <url>%2F2019%2F08%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一 弹性布局（百分比布局, 流式布局）——拉勾网、天猫首页好处：充分发挥大手机的优势——显示内容更多缺点：屏幕过大, 间距过大, 比例失调 特点： 顶部与底部的bar不管分辨率怎么变, 它的高度和位置都不变 中间每条招聘信息不管分辨率怎么变, 招聘公司的图标等信息都位于条目的左边, 薪资都位于右边 如何识别手机尺寸 通过设置meta语句： 1&lt;meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" /&gt; 在网页的中增加这句话, 可以让网页的宽度自动适应手机屏幕的宽度 也可以写成： 1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0" /&gt; 属性 描述 width 可视区域的宽度 height 可视区域的高度 device-width 设备屏幕的宽度 initial-scale 页面首次被显示时的缩放级别（0-10.0）, 取值为1时页面按实际尺寸显示, 无任何缩放 minimum-scale 设定最小缩小比例（0-10.0）, 取值为1时将禁止用户缩小至实际尺寸之下 maximum-scale 设定最大放大比例（0-10.0）, 取值为1时将禁止用户放大至实际尺寸之上 user-scalable 设定用户是否可以缩放（yes/no） viewport的概念移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域, 但viewport又不局限于浏览器可视区域的大小, 它可能比浏览器的可视区域要大, 也可能比浏览器的可视区域要小在默认情况下, 一般来讲, 移动设备上的viewport都是要大于浏览器可视区域的, 这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小, 所以为了能在移动设备上正常显示那些传统的、为桌面浏览器设计的网站, 移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值, 这个是由设备自己决定的）, 但带来的后果就是浏览器会出现横向滚动条, 因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的 关于像素在css中, 我们一般使用px作为单位, 在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素, 这可能会造成我们的一个错觉, 那就是css中的像素就是设备的物理像. 但实际情况却并非如此, css中的像素只是一个抽象的单位, 在不同的设备或不同的环境中, css中的1px所代表的设备物理像素是不同的. 在为桌面浏览器设计的网页中, 我们无需对这个斤斤计较, 但在移动设备上, 必须弄明白这点在早先的移动设备中, 屏幕像素密度都比较低, 如iphone3, 它的分辨率为320x480, 在iphone3上, 一个css像素确实是等于一个屏幕物理像素的. 后来随着技术的发展, 移动设备的屏幕像素密度越来越高, 从iphone4开始, 苹果公司便推出了所谓的Retina屏, 分辨率提高了一倍, 变成640x960, 但屏幕尺寸却没变化, 这就意味着同样大小的屏幕上, 像素却多了一倍, 这时, 一个css像素是等于两个物理像素的 注：devicePixelRatio 设备像素比 (DPR) Retina屏 —–视网膜屏幕 二 等比缩放布局（rem布局）——网易、淘宝首页1. rem 视口(viewport)设置 1&lt;meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1"&gt; 在html上根据不同分辨率设置不同 font-size 页面里除了font-size之外的其它css尺寸都使用了rem作为单位 正文的font-size需要额外的媒介查询, 并且不使用rem 例如 1234567891011121314151617181920@media screen and (max-width: 320px) &#123;body&#123; font-size: 12px; &#125;&#125;@media screen and (min-width:320px) and (max-width: 375px) &#123;body&#123; font-size: 14px; &#125;&#125;@media screen and (min-width: 375px) and (max-width: 414px) &#123;body&#123; font-size: 16px; &#125;&#125;@media screen and (min-width: 414px) &#123;body&#123; font-size: 18px; &#125;&#125; 2. VW:vw是可视区宽度单位&emsp;1vw等于可视区宽度的百分之一 100vw=相对于视窗宽度 100vh=相对于视窗高度 1vw = 1%视口宽（viewport） 在iPhone6里根字号等于100px的时候, 视口宽等于375html— font-size:100px 在iPhone6里跟字号100px,1vw==3.75 ,然后将px单位转换为vw, 让其随着视口变化而变化 1vw==3.75？ vw == 100px 26.67 vw 等于 100px 所以就将HTML的字号设置为26.67vw, 这样HTML的字号就会随着视口变化而变化了 在rem布局里, 文字不推荐准换为rem, 可以使用媒体查询]]></content>
      <tags>
        <tag>CSS HTML CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用垂直水平居中方法]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%B8%B8%E7%94%A8%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常用垂直水平居中方式123&lt;div class="box"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 12.box&#123;width: 400px;height: 400px;&#125;.child&#123;width: 100px;height: 100px;&#125; 方法一12.box&#123;position: relative;&#125;.child&#123;position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);&#125; 方法二12.box&#123;display: flex;&#125;.child&#123;margin: auto;&#125; 方法三1.box&#123;display: flex;align-items: center;justify-content: center;&#125; 方法四12.box&#123;display: table-cell;vertical-align: middle;text-align: center;&#125;.child&#123;display: inline-block;&#125; 方法五12.box&#123;position: relative;&#125;.child&#123;position: absolute;top: 0;right: 0;bottom: 0;left: 0;margin: auto;&#125;]]></content>
      <tags>
        <tag>CSS HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画练习 图片切换]]></title>
    <url>%2F2019%2F08%2F15%2FCSS3%E5%8A%A8%E7%94%BB%E7%BB%83%E4%B9%A0%EF%BC%9A%E4%B8%91%E7%9A%84%E4%B8%80%E5%8C%B9%E7%9A%84%E5%9B%BE%E7%89%87%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[8月15号的练习，css3 2D动画 看起来对资源的占用量似乎很高 定义动画时会使用大量代码 尝试使用 order 来代替 disappear 动画，失败 图片路径为当前路径下 bg1.jpg, bg2.jpg 以及bg3 bg4 bg5.jpg 感受到了css3动画学习的简便，似乎比js要简单一些 遗留问题：order 到底要在什么情况下使用结构 12345678910111213141516171819202122232425&lt;body&gt; &lt;img src="bg1.jpg" id="p1" alt=""&gt; &lt;img src="bg2.jpg" id="p2" alt=""&gt; &lt;img src="bg3.jpg" id="p3" alt=""&gt; &lt;img src="bg4.jpg" id="p4" alt=""&gt; &lt;img src="bg5.jpg" id="p5" alt=""&gt; &lt;ul&gt; &lt;li&gt; &lt;a href="#p1"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#p2"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#p3"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#p4"&gt;&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#p5"&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;style&gt; *&#123;margin: 0;padding: 0;&#125; html, body&#123;height: 100%;&#125; body&#123;overflow: hidden;&#125; img&#123;width: 100%;height: 100%;position: absolute;z-index: 1;&#125; img:not(:target)&#123;animation: disappear 3s;&#125; ul&#123;width: 100%;height: 174px;text-align: center;position: relative;z-index: 1000;top: 60%;&#125; li&#123;height: 170px;width: 174px;border: 2px solid #fff;border-radius: 5px;display: inline-block;margin: 0 5px;&#125; a&#123;background-color: #ccc;font-size: 14px;font-weight: bold;font-style: italic;text-shadow: -3px -5px 5px rgba(102, 102, 102, .4); display: block;width: 100%;height: 100%;box-sizing: border-box;border-radius: 3px;position: relative;&#125; a::before&#123;content: "";width: 130px;height: 130px;box-sizing: border-box;border: 5px solid #fff;left: 20px;top: -65px;background-size: 350px 200px;background-repeat: no-repeat;background-position-x: -100px;&#125; a::after&#123;content: "";width: 120px;height: 120px;background-color: rgba(0, 0, 0, .4);left: 25px;top: -60px;&#125; a::before, a::after&#123;border-radius: 50%;display: block;position: absolute;transition: all .2s linear;&#125; a:hover::after&#123;opacity: 0;&#125; #p1:target&#123;z-index: 100;animation: animation1 .5s forwards;&#125; #p2:target&#123;z-index: 100;animation: animation2 1s forwards;&#125; #p3:target&#123;z-index: 100;animation: animation3 .8s forwards;&#125; #p4:target&#123;z-index: 100;animation: animation4 .5s forwards;&#125; #p5:target&#123;z-index: 100;animation: animation5 .8s forwards;&#125; li:nth-child(1) a&#123;background-color: #02646e&#125; li:nth-child(2) a&#123;background-color: #eb0837&#125; li:nth-child(3) a&#123;background-color: #67b374&#125; li:nth-child(4) a&#123;background-color: #e6674a&#125; li:nth-child(5) a&#123;background-color: #e61061&#125; li:nth-child(1) a::before&#123;background-image: url(bg1.jpg);&#125; li:nth-child(2) a::before&#123;background-image: url(bg2.jpg);&#125; li:nth-child(3) a::before&#123;background-image: url(bg3.jpg);&#125; li:nth-child(4) a::before&#123;background-image: url(bg4.jpg);&#125; li:nth-child(5) a::before&#123;background-image: url(bg5.jpg);&#125; @keyframes animation1&#123; 0%&#123;width: 0;height: 0;&#125; 30%&#123;width: 0;height: 100%;&#125; 100%&#123;width: 100%;height: 100%;&#125; &#125; @keyframes animation2&#123; 0%&#123;transform: rotate(0);width: 0;height: 0;margin: auto;left: 0;right: 0;top: 0;bottom: 0;&#125; 100%&#123;transform: rotate(360deg);width: 100%;height: 100%;left: 0;right: 0;top: 0;bottom: 0;margin: auto;&#125; &#125; @keyframes animation3&#123; 0%&#123;width: 0;height: 0;transform: scale(0);margin: auto;left: 0;right: 0;top: 0;bottom: 0;&#125; 100%&#123;width: 100%;height: 100%;transform: scale(100%);margin: auto;left: 0;right: 0;top: 0;bottom: 0;&#125; &#125; @keyframes animation4&#123; 0%&#123;right: 100%;&#125; 100%&#123;right: 0;&#125; &#125; @keyframes animation5&#123; 0%&#123;opacity: 0;&#125; 100%&#123;opacity: 1;&#125; &#125; @keyframes disappear&#123; 0%&#123;z-index: 100;&#125; 100%&#123;z-index: 1;&#125; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>CSS CSS3 HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[190815随记]]></title>
    <url>%2F2019%2F08%2F15%2F190815%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.inline-block 垂直不对齐的情况 inline-block 会默认基线对齐，在对容器使用时，因内部文字数量及字号行高不同，可能会影响对齐效果。 解决方案：在类型为 inline-block 的容器上添加 vertical-align: top; 2.动画练习时遇到的问题的解决方案 12345@keyframes disappear&#123; 0%&#123;z-index: 100;&#125; 100%&#123;z-index: 1;&#125;&#125;img:not(:target)&#123;animation: disappear 3s;&#125; 3.经常忘记的属性 文本倾斜 font-style: italic]]></content>
      <tags>
        <tag>CSS HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[placeholder文字水平居中]]></title>
    <url>%2F2019%2F08%2F14%2Fplaceholder%E6%96%87%E5%AD%97%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[placeholder中文字实现水平居中的方法1234input::placeholder&#123;text-align: center;&#125;input::-ms-input-placeholder&#123;text-align: center;&#125;input::-moz-input-placeholder&#123;text-align: center;&#125;input::-webkit-input-placeholder&#123;text-align: center;&#125;]]></content>
      <tags>
        <tag>CSS HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 动画]]></title>
    <url>%2F2019%2F08%2F14%2FCSS3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[一 渐变 IE10+线性渐变linear-gradient1background-image: linear-gradient(方向，起始颜色，结束颜色) 处理兼容12345background-image: -webkit-linear-gradient(to top, red, yellow);background-image: -moz-linear-gradient(to top, red, yellow);background-image: -o-linear-gradient(to top, red, yellow);background-image: -ms-linear-gradient(to top, red, yellow);background-image: linear-gradient(to top, red, yellow); 方向可以使用角度 (30deg) 也可以使用关键字 (to right等)12345to top:0deg 360deg -360deg;to bottom:180deg -180deg;to right:90deg -270deg;to left:-90deg 270deg;to top left:从右下角到左上角 多色线性渐变，只需在后面添加更多的颜色即可12background-image: linear-gradient(to top, red, yellow, blue, green, orange) 自定义线性渐变123456789101112background-image: linear-gradient( to top, rgba(255, 206, 0, .5) 0%, rgba(255, 255, 0, .4) 10%, rgba(255, 104, 0, .6) 15%, rgba(255, 0, 255, .5) 20%, rgba(255, 0, 206, .8) 40%, rgba(255, 0, 200, .5) 50%, rgba(255, 0, 222, .9) 60%, rgba(255, 123, 0,.2) 80%, rgba(255, 108, 0,.5) 100%) 重复线性渐变12345background-image: repeating-linear-gradient( to top, rgba(255,206, 0, .5) 40px, rgba(255,255, 0, .4) 80px) 径向渐变radial-gradient12345678910111213background-image: radial-gradient(形状 at 圆心坐标, 颜色)background-image:radial-gradient(主要半径 次要半径 at 水平 垂直, red, yellow)background-image:radial-gradient(50px 100px at 200px 250px, red, yellow)background-image:radial-gradient(主次半径相等就是圆 at 水平 垂直,red,yellow)background-image:radial-gradient(circle at right bottom, red, yellow)background-image:radial-gradient(主次半径不相等是椭圆 at 水平 垂直,red,yellow)background-image:radial-gradient(ellipse at top, red, yellow)background-image:radial-gradient(圆心与中心重合,red,yellow)background-image:radial-gradient(circle, red, yellow) 重复径向渐变12345background-image: repeating-radial-gradient( to top, rgba(255, 206, 0, .5) 40px, rgba(255, 255, 0, .4) 80px) 二 过渡 IE10+transition: 属性 意义 transition-property 过渡属性 transition-delay 过渡延迟时间 transition-duration 过渡所需时间 transition-timing-function 过渡动画函数 各个属性可以分开写，一次可以过渡多个属性123456789101112131415161718192021222324-webkit-transition-property:background, width, height;-webkit-transition-duration:1s, 1s, 1s;-webkit-transition-timing-function:linear, linear, linear;-webkit-transition-delay:1s, 0s, 2s;-moz-transition-property:background, width, height;-moz-transition-duration:1s, 1s, 1s;-moz-transition-timing-function:linear, linear, linear;-moz-transition-delay:1s, 0s, 2s;-ms-transition-property:background, width, height;-ms-transition-duration:1s,1s,1s;-ms-transition-timing-function:linear, linear, linear;-ms-transition-delay:1s, 0s, 2s;-o-transition-property:background, width, height;-o-transition-duration:1s, 1s, 1s;-o-transition-timing-function:linear, linear, linear;-o-transition-delay:1s, 0s, 2s;transition-property:background, width, height;transition-duration:1s, 1s, 1s;transition-timing-function:linear, linear, linear;transition-delay:1s, 0s, 2s; 注：过渡动画函数 timing-function 属性值 效果 ease 先快后慢，逐渐变慢 linear 匀速 ease-in 速度越来越快，称为渐显效果 ease-out 速度越来越慢，称为渐隐效果 ease-in-out 先加速再减速，称为渐显渐隐效果 cubic-bezier( .61, .17, .92, .1 ) 三次贝塞尔曲线 三 变形 transform2D变形 transform-function### 属性 取值 说明 translate (x,y) 单一方向偏移可以直接使用：translateX( ) 和 translateY( ); scale (x,y) 绝对值小于 1 为缩小，大于 1 放大 ;只写一个值代表四周同时放大缩小 ; 取值可以为负数，负数时会进行翻转后再缩放 rotate (deg) 正数时顺时针旋转，负数时逆时针旋转 skew (x,y) 单一方向倾斜可以直接使用：skewX( ) 和 skewY( ); transform-origin 指定元素的中心点位置可以是百分数，数值，方向单词 transform-origin: 50% 50%; transform-origin: 20px 100px; transform-origin: center bottom; 四 3D 变形浏览器支持情况Internet Explorer 10 和 Firefox 支持 3D 变形Chrome 和 Safari 需要前缀 -webkit-Opera 仍然不支持 3D 变形 (它只支持 2D 变形) 变形类型 transform-style: preserve-3d实现一些3D效果的时候，transform-style: preserve-3d是少不了的一般而言，该声明应用在3D变换的兄弟元素们的父元素上 preserve-3d 放到父元素上 12345-webkit-transform-style: preserve-3d;-moz-transform-style: preserve-3d;-ms-transform-style: preserve-3d;-o-transform-style: preserve-3d;transform-style: preserve-3d; perspective：透视，视角，景深写到父元素上 1234-webkit-perspective: 1200px;-moz-perspective: 1200px;-ms-perspective: 1200px;perspective: 1200px; perspective的两种书写方式perspective:1200px;transform:perspective(1200px) 属性 描述 transform: translate3d(x,y,z) 3D位移 transform:translateX() X轴位移 transform:translateY() Y轴位移 transform:translateZ() Z轴位移 transform: rotate3d(x, y, z, deg) 3D旋转 transform: rotateX() X轴旋转 transform: rotateY() Y轴旋转 transform: rotateZ() Z轴旋转 transform: scale3d() 3D缩放，不能自己单独使用，需要配合其他变形一起使用才会有效果 transform: scaleX() X轴缩放 transform: scaleY() Y轴缩放 transform: scaleZ() Z轴缩放 # 五 CSS3动画 相关动画属性animation: 动画名称 动画所需时间 动画播放方式 动画开始时间 循环次数 播放方向 属性 描述 animation-name 动画名称—-声明的动画名称 animation-duration 所需时间—-完成0%-100%动画所需时间 animation-timing-function 播放方式—-同过渡 step-start 阻止帧与帧之间的过渡，瞬间切换到下一帧 animation-delay 延迟播放的时间 animation-iteration-count 循环次数—-默认为1，infinite为无限循环播放 animation-direction 播放方向—-默认normal，向前播放 alternate，播放次数为偶数则向前播放，为奇数时向反方向播放 animation-play-state 动画状态 running 动起来 paused暂停 关键帧声明动画 @keyframes@keyframes name{ from{ css样式; } percentage{ css样式; } to{ css样式; }} @keyframes name{ 0%{ css样式; } percentage{ css样式; } 100%{ css样式; }} 调用@keyframes声明的动画animation:run 1s infinite alternate ;]]></content>
      <tags>
        <tag>CSS CSS3 HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画练习 旋转的正方体]]></title>
    <url>%2F2019%2F08%2F14%2FCSS3%E5%8A%A8%E7%94%BB%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%97%8B%E8%BD%AC%E7%9A%84%E6%AD%A3%E6%96%B9%E4%BD%93%2F</url>
    <content type="text"><![CDATA[8月14号的练习 纯CSS 主要属性：transform, position, transition 大量冗余代码 效果不甚如意 图片路径：images/ 图片名称 01.jpg, 02.jpg 以及03 04 05 06.jpg 结构 1234567891011121314151617181920&lt;body&gt; &lt;div class="all"&gt; &lt;div class="boxA"&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="boxB"&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;div class="face"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 样式1234567891011121314151617181920212223242526272829303132333435363738body&#123;background-color: #000;perspective: 1500px;&#125;.all&#123;transform-style: preserve-3d;margin: 150px auto;perspective-origin: center center;position: relative;width: 302px;height: 302px;&#125;.face&#123;background-size: cover;&#125;.boxA&#123;position: absolute;transform-style: preserve-3d;width: 302px;height: 302px;animation: rotA 10s infinite linear;&#125;.boxA .face&#123;width: 300px;height: 300px;position: absolute;opacity: .5;border: 1px solid #000;transition: all 1s linear;&#125;.boxA .face:nth-child(1)&#123;transform: translateZ(-150px);background: url(images/01.jpg);&#125;.boxA .face:nth-child(2)&#123;transform: rotateY(180deg) translateZ(-150px);background: url(images/02.jpg);&#125;.boxA .face:nth-child(3)&#123;transform: rotateX(90deg) translateZ(-150px);background: url(images/03.jpg);&#125;.boxA .face:nth-child(4)&#123;transform: rotateX(-90deg) translateZ(-150px);background: url(images/04.jpg);&#125;.boxA .face:nth-child(5)&#123;transform: rotateY(90deg) translateZ(-150px);background: url(images/05.jpg);&#125;.boxA .face:nth-child(6)&#123;transform: rotateY(-90deg) translateZ(-150px);background: url(images/06.jpg);&#125; .boxA:hover .face:nth-child(1)&#123;transform: translateZ(-200px);background: url(images/01.jpg);&#125;.boxA:hover .face:nth-child(2)&#123;transform: rotateY(180deg) translateZ(-200px);background: url(images/02.jpg);&#125;.boxA:hover .face:nth-child(3)&#123;transform: rotateX(90deg) translateZ(-200px);background: url(images/03.jpg);&#125;.boxA:hover .face:nth-child(4)&#123;transform: rotateX(-90deg) translateZ(-200px);background: url(images/04.jpg);&#125;.boxA:hover .face:nth-child(5)&#123;transform: rotateY(90deg) translateZ(-200px);background: url(images/05.jpg);&#125;.boxA:hover .face:nth-child(6)&#123;transform: rotateY(-90deg) translateZ(-200px);background: url(images/06.jpg);&#125; .boxB&#123;position: absolute;transform-style: preserve-3d;width: 100px;height: 100px;animation: rotB 10s infinite linear;margin: 100px;&#125;.boxB .face&#123;width: 100px;height: 100px;position: absolute;transition: all 1s linear;&#125;.boxB .face:nth-child(1)&#123;transform: translateZ(-50px);background: url(images/01.jpg);&#125;.boxB .face:nth-child(2)&#123;transform: rotateY(180deg) translateZ(-50px);background: url(images/02.jpg);&#125;.boxB .face:nth-child(3)&#123;transform: rotateX(90deg) translateZ(-50px);background: url(images/03.jpg);&#125;.boxB .face:nth-child(4)&#123;transform: rotateX(-90deg) translateZ(-50px);background: url(images/04.jpg);&#125;.boxB .face:nth-child(5)&#123;transform: rotateY(90deg) translateZ(-50px);background: url(images/05.jpg);&#125;.boxB .face:nth-child(6)&#123;transform: rotateY(-90deg) translateZ(-50px);background: url(images/06.jpg);&#125;@keyframes rotA&#123; 0%&#123;transform: rotateY(0) rotateZ(0) rotateX(0)&#125; 100%&#123;transform: rotateY(359deg) rotateZ(359deg) rotateX(359deg)&#125;&#125;@keyframes rotB&#123; 0%&#123;transform: rotateX(0) rotateZ(0) rotateY(0)&#125; 100%&#123;transform: rotateX(359deg) rotateZ(359deg) rotateY(359deg)&#125;&#125;]]></content>
      <tags>
        <tag>CSS CSS3 HTML</tag>
      </tags>
  </entry>
</search>
